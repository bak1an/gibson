{"name":"Gibson","tagline":"A high performance tree-based cache server.","body":"Gibson [![Build Status](https://secure.travis-ci.org/evilsocket/gibson.png)](http://travis-ci.org/evilsocket/gibson)\r\n===\r\n\r\n* To report issues : <http://github.com/evilsocket/gibson/issues>\r\n* Gibson website   : <http://gibson-db.in> \r\n* Documentation    : <http://gibson-db.in/documentation.php> \r\n\r\n**Table of Contents**\r\n\r\n* [Introduction](#introduction)\r\n* [Features](#features)\r\n* [Compilation](#compilation)\r\n* [Configuration](#configuration)\r\n* [Using the console client](#using-the-console-client)\r\n* [Command Reference](http://gibson-db.in/commands.php)\r\n* [Clients](http://gibson-db.in/clients.php)\r\n* [Protocol Specifications](http://gibson-db.in/protocol.php)\r\n* [Data Model](#data-model)\r\n* [License](#license)\r\n\r\n* * *\r\n\r\n## Introduction\r\n\r\nGibson is a high efficiency, [tree based](#datamodel) memory cache server.\r\nNormal key-value stores ( memcache, Redis, etc ) uses a hash table as their main data structure, so every key is hashed with a specific algorithm and the resulting hash is used to identify the given value in memory. This approach, although very fast, doesn't allow the user to execute globbing expressions/selections on a given (multiple) keyset, thus resulting on a pure one-by-one access paradigm.\r\nGibson is different, it uses a special tree based structure allowing the user to perform operations on multiple key sets using a prefix expression achieving the same performance grades in the worst case, even better on an average case.\r\nUnlike many other server applications, it's not multithreaded, but it uses multiplexing taking advantace of an event-driven network layer ( just like Node.js, or Nginx using libevent and so on ) which provides higher performances even on low cost hardware.\r\n\r\n**You need Gibson if:**\r\n\r\n* You need to cache result sets from heavy queries lowering your main database load and response times.\r\n* You want to invalidate or rietrive multiple cached itemshierarchically with a single command given their common prefix, in lower than linear time.\r\n* You need a cache backend which is fast, highly scalable and not redundant as the common key value store.\r\n\r\n**You can't use Gibson to:**\r\n\r\n* You can't use Gibson as a drop in replacement for your database, since it is NOT a database but a key value store.\r\n* You need complex data structures such as lists, sets, etc to be cached as they are ( without serializing it ).\r\n* You need to perform sorting on cached items.\r\n\r\n## Features\r\n\r\n* Very fast and with the lowest memory footprint possible\r\n* Fast LZF object compression\r\n* Builtin object Time-To-Live\r\n* Cached object locking and unlocking\r\n* Multiple key set operation with M* operators \r\n\r\n## Compilation\r\n\r\nGibson is still hosted as source code release on Github, in order to run it you will have to compile sources, therefore you will need **git**, **cmake**, **gcc** and **build-essential** packages installed on your computer.\r\n\r\nYou have two options to obtain the source code, one is cloning the github repository using git:\r\n\r\n    git clone https://github.com/evilsocket/gibson.git\r\n\r\nOr you can download the source code archive [from here](https://github.com/evilsocket/gibson/archive/unstable.zip).\r\n\r\nOnce you got the source code, all you have to do is compile Gibson, the process is pretty straightforward.\r\n\r\n    $ cd gibson\r\n    $ cmake . [compilation options]\r\n    $ make\r\n    # make install\r\n\r\nWhere **compilation options** might be:\r\n\r\n    -DWITH_DEBUG=1\r\n\r\nTo compile with debug symbols and without optimizations ( for devs ).\r\n\r\n    -DWITH_JEMALLOC=1\r\n\r\nTo use the [jemalloc memory allocator](http://gibson-db.in/blog/gibson-is-now-optionally-jemalloc-powered.html) instead of the standard one.\r\n\r\n## Configuration\r\n\r\nAfter [compiling and installing](#compilation) Gibson source code release, you might want to edit the configuration file situated in\r\n**/etc/gibson/gibson.conf**, even if [standard values](https://raw.github.com/evilsocket/gibson/master/gibson.conf) will fit the majority of situations.\r\n\r\nLet's see each configuration directive purpose.\r\n\r\n### logfile\r\n\r\nThe log file path, or /dev/stdout to log on the terminal output.\r\n\r\n### loglevel\r\n\r\nInteger number representing the verbosity of the log manager:\r\n\r\n* 0 for **DEBUG** verbosity, every message even debug ones will be logged.\r\n* 1 for **INFO** verbosity, only information messages, warning, errors and criticals will be logged.\r\n* 2 for **WARNING** verbosity, only warnings, errors and criticals will be logged\r\n* 3 for **ERROR** verbosity, only errors and criticals will be logged.\r\n* 4 for **CRITICAL** verbosity, only segmentation faults will be logged.\r\n\r\n### logflushrate\r\n\r\nHow often to flush logfile, where 1 stands for \"flush the log file every new line\".\r\n\r\n### unix_socket\r\n\r\nThe UNIX socket path to use if Gibson will run in a local environment, use the directives **address** and **port** to create\r\na TCP server instead.\r\n\r\n### address\r\n\r\nAddress to bind the TCP server to.\r\n\r\n### port\r\n\r\nTCP port to use for server listening.\r\n\r\n### daemonize\r\n\r\nIf 1 the process server will be daemonized ( put on background ), otherwise will run synchronously with the caller process.\r\n\r\n### pidfile\r\n\r\nFile to be used to save the current Gibson process id.\r\n\r\n### max_memory\r\n\r\nMaximum memory to be used by the Gibson server, when this value is reached, the server will try to deallocate old objects to free space ( see **gc_ratio** ) and, if \r\nthere aren't freeable objects at the moment, will refuse to accept new objects with a **REPL_ERR_MEM** error reply.\r\n\r\n### gc_ratio\r\n\r\nIf **max_memory** is reached, data that is not being accessed in this amount of time ( i.e. gc_ratio 1h = data that is not being accessed in the last hour ) get deleted to release memory for the server.\r\n\r\n### max_item_ttl\r\n\r\nMaximum time-to-live an object can have.\r\n\r\n### max_idletime\r\n\r\nMaximum time in seconds a client can be idle ( without read or write operations ), after this period the client connection will be closed.\r\n\r\n### max_clients\r\n\r\nMaximum number of clients Gibson can hadle concurrently.\r\n\r\n### max_request_size\r\n\r\nMaximum size of a client request.\r\n\r\n### max_key_size\r\n\r\nMaximum size of the key for a Gibson object.\r\n\r\n### max_value_size\r\n\r\nMaximum size of the value for a Gibson object.\r\n\r\n### max_response_size\r\n\r\nMaximum Gibson response size, used to limit I/O when a M* operator is used.\r\n\r\n### compression\r\n\r\nObjects above this size will be compressed in memory.\r\n\r\n### cron_period\r\n\r\nNumber of milliseconds between each cron schedule, do not put a value higher than 1000.\r\n\r\n* * *\r\n\r\n## Using the console client\r\n\r\nOnce your Gibson instance is up and running, you might want to download and install its [client library](https://github.com/evilsocket/libgibsonclient) which provides the default\r\nconsole client too.\r\n\r\n    $ git clone https://github.com/evilsocket/libgibsonclient.git\r\n    $ cd libgibsonclient\r\n    $ git submodule init\r\n    $ git submodule update\r\n    $ cmake .\r\n    $ make\r\n    # make install\r\n\r\nThe client command line arguments are pretty straightforward:\r\n    # gibson-cli -h                                                                                                                             \r\n    Gibson client utility.\r\n    \r\n    gibson-cli [-h|--help] [-a|--address ADDRESS] [-p|--port PORT] [-u|--unix UNIX_SOCKET_PATH]\r\n    \r\n      -h, --help            \t  Print this help and exit.\r\n      -a, --address ADDRESS   \t  TCP address of Gibson instance.\r\n      -p, --port PORT   \t\t  TCP port of Gibson instance.\r\n      -u, --unix UNIX_SOCKET_PATH Unix socket path of Gibson instance ( overrides TCP arguments ).\r\n\r\nSo if you want to connect to a TCP instance, you will type for instance:\r\n\r\n    gibson-cli --address 127.0.0.1 --port 10128\r\n    \r\nOr, to connect to a Unix socket instance:\r\n\r\n    gibson-cli --unix /var/run/gibson.sock\r\n\r\nOnce you are connected, you will see a prompt like this:\r\n\r\n    type :quit or :q to quit.\r\n    \r\n    127.0.0.1:10128>\r\n\r\nNow you can start using the client typing the command you want to execute.\r\n\r\nFor a complete command list ( and their syntax ), refer to the [protocol specs](http://gibson-db.in/protocol.php) and/or type the command string\r\nto see its synax, for instance:\r\n\r\n    127.0.0.1:10128> set\r\n    ERROR: Invalid parameters, correct syntax is:\r\n    \tSET <ttl> <key> <value>\r\n\r\n## Data Model\r\n\r\nMost of the content of this document was taken from [this page](http://en.wikipedia.org/wiki/Trie) on Wikipedia.\r\n\r\nUnlike many other key value stores, Gibson doesn't use a hash table as its main data structure, but a special type of tree called **Trie**\r\n\r\nIn computer science, a trie, also called digital tree or prefix tree, is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. Unlike a binary search tree, no node in the tree stores the key associated with that node; instead, its position in the tree defines the key with which it is associated. All the descendants of a node have a common prefix of the string associated with that node, and the root is associated with the empty string. Values are normally not associated with every node, only with leaves and some inner nodes that correspond to keys of interest. For the space-optimized presentation of prefix tree, see compact prefix tree.\r\n\r\nThe term trie comes from retrieval. This term was coined by Edward Fredkin, who pronounces it /ˈtriː/ \"tree\" as in the word retrieval.\r\n\r\nIn the example shown, keys are listed in the nodes and values below them. Each complete English word has an arbitrary integer value associated with it. A trie can be seen as a deterministic finite automaton, although the symbol on each edge is often implicit in the order of the branches.\r\n\r\nIt is not necessary for keys to be explicitly stored in nodes. (In the figure, words are shown only to illustrate how the trie works.)\r\n\r\nThough tries are most commonly keyed by character strings, they need not be. The same algorithms can easily be adapted to serve similar functions of ordered lists of any construct, e.g., permutations on a list of digits or shapes. In particular, a bitwise trie is keyed on the individual bits making up a short, fixed size of bits such as an integer number or memory address.\r\n\r\n![trie data model](http://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png)\r\nA trie for keys \"A\", \"to\", \"tea\", \"ted\", \"ten\", \"i\", \"in\", and \"inn\".\r\n\r\n### Advantages over a Hash Table\r\n\r\nA trie can be used to replace a hash table, over which it has the following advantages:\r\n\r\n* Looking up data in a trie is faster in the worst case, O(m) time (where m is the length of a search string), compared to an imperfect hash table. An imperfect hash table can have key collisions. A key collision is the hash function mapping of different keys to the same position in a hash table. The worst-case lookup speed in an imperfect hash table is O(N) time, but far more typically is O(1), with O(m) time spent evaluating the hash.\r\n* There are no collisions of different keys in a trie.\r\n* Buckets in a trie which are analogous to hash table buckets that store key collisions are necessary only if a single key is associated with more than one value.\r\n* There is no need to provide a hash function or to change hash functions as more keys are added to a trie.\r\n* A trie can provide an alphabetical ordering of the entries by key.\r\n\r\nTries do have some drawbacks as well:\r\n\r\n* Tries can be slower in some cases than hash tables for looking up data, especially if the data is directly accessed on a hard disk drive or some other secondary storage device where the random-access time is high compared to main memory. ( **Not in the Gibson case** )\r\n* Some keys, such as floating point numbers, can lead to long chains and prefixes that are not particularly meaningful. Nevertheless a bitwise trie can handle standard IEEE single and double format floating point numbers. ( **Not in the Gibson case** )\r\n* Some tries can require more space than a hash table, as memory may be allocated for each character in the search string, rather than a single chunk of memory for the whole entry, as in most hash tables.\r\n\r\nFor more details refer to [this Wikipedia page](http://en.wikipedia.org/wiki/Trie).\r\n\r\n## License\r\n\r\nReleased under the BSD license.  \r\nCopyright &copy; 2013, Simone Margaritelli <evilsocket@gmail.com>  \r\nAll rights reserved.\r\n","google":"UA-41235708-1","note":"Don't delete this file! It's used internally to help with page regeneration."}